#!/usr/bin/perl -w
use strict;
use warnings;

# WIP
#
# TODO alternative dates
# TODO balance assertions
# TODO in-comment tags, e.g., "; :tommaso:battesimo-tz" or ":todo:"

# mapping of ledger metadata key to corresponding beancount key
my %metadata_map = (
    'label'   => 'bank-label',
    'x-payer' => 'payer',
    );

my $indent = "  ";
my ($in_txn, %cur_txn_header, @cur_txn_lines);

# Simple parsing state machine: we need to look ahead for payee metadata, as in
# beancount they appear on the first line of a transaction, whereas in ledger
# they appear as a regular metadata ("x-payee"). The following functions
# support the parsing state machine for this:

# reset current parsing state, reinitializing it to the empty state
sub reset_cur_txn() {
    $in_txn = 0;
    %cur_txn_header = ();
    @cur_txn_lines = ();
}
reset_cur_txn();


# pretty print the transaction header (i.e., its first line) in beancount
# format
sub pp_cur_txn_header() {
    my $buf = "";

    $buf .= $cur_txn_header{date} . " ";
    $buf .= $cur_txn_header{flag} . " ";
    if (exists($cur_txn_header{payee})) {
	$buf .= '"' . $cur_txn_header{payee} . '" ';
    }
    $buf .= '"' . $cur_txn_header{narration} . "\"\n";

    return $buf;
}

# pretty print subsequent lines (all but the first) of a transaction, in
# beancount format
sub pp_cur_txn_lines() {
    my $buf = "";

    foreach my $line (@cur_txn_lines) {
	$buf .= $line;
    }

    return $buf;
}

# pretty print a single metadata line, in beancount format
sub pp_txn_metadata($$$) {
    my ($depth, $key, $value) = @_;
    return "$indent" x $depth . $key . ": $value\n";
}

# dump the current parsing state to stdout. Used for debugging purposes only
sub dump_cur_txn() {
    if ($in_txn) {
	print "D: cur_header: " . pp_cur_txn_header();
	print "D: cur_lines_begin\n";
	print(pp_cur_txn_lines());
	print "D: cur_lines_end\n";
    } else {
	print "D: no txn\n";
    }
}


# set the current transaction header (= first line), overriding the previous
# value (which should *usually* be empty, but it is the caller responsibility
# to ensure this is the case)
sub push_txn_header($$$) {
    my ($date, $flag, $narration) = @_;

    $in_txn = 1;
    $cur_txn_header{date} = $date;
    $cur_txn_header{flag} = $flag;
    $cur_txn_header{narration} = $narration;
}

# set the current transaction payee, complementing the transaction header
sub push_txn_payee($) {
    my ($payee) = @_;
    $cur_txn_header{payee} = $payee;
}

# add a transaction line. Call this multiple times to accmulate lines that will
# be emitted as soon as the transaction is over
sub push_txn_line($) {
    my ($line) = @_;

    push @cur_txn_lines, $line;
}


# return a pretty printed transaction, reseting the current parsing state. This
# is usually called as soon as the end of a transaction (usually an empty line)
# is encountered
sub pop_txn() {
    my $buf = "";

    $buf .= pp_cur_txn_header();
    $buf .= pp_cur_txn_lines();

    reset_cur_txn();

    return $buf;
}


# parse a ledger value. Usually to extract "semantic" values from typed
# metadata
sub parse_ledger_value($) {
    my ($raw) = @_;
    my $value;

    if ($raw =~ /^\[(?<date>\d{4}-\d{2}-\d{2})\]$/) {
	$value = $+{date};
    } else {
	$value = $raw;
    }

    return $value;
}


# map a (ledger) metadata key to the desired (beancount) metadata key. Relies
# on the global %metadata_map hash
sub map_metadata($) {
    my ($key) = @_;

    if (exists($metadata_map{$key})) {
	return $metadata_map{$key};
    } else {
	return $key;
    }
}


# MAIN CONVERSION LOOP

my $lineno = 0;
while (my $l = <>) {
    $lineno++;
    chomp $l;

    # print "D: line: ", $lineno, "\n"; dump_cur_txn(); print "\n";
    if ($l =~ /^include\s+(?<filename>.*)\.ledger/) {  # include
	print "include \"$+{filename}.beancount\"\n";
    } elsif ($l =~ /^(?<date>[0-9]\S+)\s+(?<flag>[*!])\s+(?<narration>.*)/) {  # txn header
	push_txn_header($+{date}, $+{flag}, $+{narration});
    } elsif ($l =~ /^(?<indent>\s+);\s*(?<key>[\w-]+):(?<typed>:)?\s*(?<value>.*)/) {  # metadata
	my $key = map_metadata(lc($+{key}));
	my $value;
	if (defined($+{typed})) {
	    $value = parse_ledger_value($+{value});
	} else {
	    $value = '"' . $+{value} . '"';
	}
	if ($key eq "x-payee") {
	    push_txn_payee($+{value});
	} else {
	    push_txn_line(pp_txn_metadata(length($+{indent}) / 2,
					  $key, $value));
	}
    } elsif ($l =~ /^(?<indent>\s+);\s*(?<comment>.*)/) {  # non-metadata comment
	if ($in_txn) {
	    # work-around for
	    # https://bitbucket.org/blais/beancount/issues/143/full-line-comments-not-allowed-within
	    push_txn_line(pp_txn_metadata(length($+{indent}) / 2,
					  "comment", '"' . $+{comment} . '"'));
	} else {
	    print $l, "\n";
	}
    } elsif ($l =~ /^\s*$/) {  # empty line
	print(pop_txn()) if $in_txn;
	print "\n";
    } else {
	if ($in_txn) {
	    push_txn_line($l . "\n");
	} else {
	    print $l, "\n";
	}
    }
}

# emit last transaction, if it's still active when reaching EOF
print(pop_txn()) if $in_txn;
