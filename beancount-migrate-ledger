#!/usr/bin/perl -w
use strict;
use warnings;

# WIP
#
# TODO alternative dates
# TODO balance assertions

use POSIX qw(ceil);

my $payee_tag = 'x-payee';

# mapping of ledger metadata key to corresponding beancount key
my %metadata_map = (
    'label'   => 'bank-label',
    'x-payer' => 'payer',
    );


# indentation length, for ledger and beancount
my $beancount_indent = 2;
my $ledger_indent = 4;

# indent some content at a given depth in beancount style
sub indent($$) {
    my ($depth, $content) = @_;

    return ' ' x ($depth * $beancount_indent) . $content;
}


# Simple parsing state machine: we need to look ahead for payee metadata, as in
# beancount they appear on the first line of a transaction, whereas in ledger
# they appear as a regular metadata ("x-payee"). The following functions
# support the parsing state machine for this:
my ($in_txn, %cur_txn_header, @cur_txn_lines);


# reset current parsing state, reinitializing it to the empty state
sub reset_cur_txn() {
    $in_txn = 0;
    %cur_txn_header = ();
    @cur_txn_lines = ();
}
reset_cur_txn();


# pretty print the transaction header (i.e., its first line) in beancount
# format
sub pp_cur_header() {
    my $buf = "";

    $buf .= $cur_txn_header{date} . " ";
    $buf .= $cur_txn_header{flag} . " ";
    if (exists($cur_txn_header{payee})) {
	$buf .= '"' . $cur_txn_header{payee} . '" ';
    }
    $buf .= '"' . $cur_txn_header{narration} . "\"";

    return $buf;
}

# pretty print subsequent lines (all but the first) of a transaction, in
# beancount format
sub pp_cur_lines() {
    my $buf = "";

    foreach my $line (@cur_txn_lines) {
	$buf .= $line . "\n";
    }

    return $buf;
}

# pretty print a single metadata key/value paris, in beancount format
sub pp_metadata($$) {
    my ($key, $value) = @_;

    return "$key: $value";
}

# pretty print in-transaction tags, in beancount format
sub pp_tags(@) {
    my @tags = @_;

    # XXX workaround for the fact that per-posting tags are currently not
    # allowed.  See:
    # https://groups.google.com/forum/#!topic/beancount/XPtFOnqCVws
    return "tags: \"" . join(', ', @tags) . "\"";
}

# dump the current parsing state to stdout. Used for debugging purposes only
sub dump_cur_txn() {
    if ($in_txn) {
	print "D: cur_header: " . pp_cur_header() . "\n";
	print "D: cur_lines_begin\n";
	print(pp_cur_lines());
	print "D: cur_lines_end\n";
    } else {
	print "D: no txn\n";
    }
}


# set the current transaction header (= first line), overriding the previous
# value (which should *usually* be empty, but it is the caller responsibility
# to ensure this is the case)
sub push_header($$$) {
    my ($date, $flag, $narration) = @_;

    $in_txn = 1;
    $cur_txn_header{date} = $date;
    $cur_txn_header{flag} = $flag;
    $cur_txn_header{narration} = $narration;
}

# set the current transaction payee, complementing the transaction header
sub push_payee($) {
    my ($payee) = @_;
    $cur_txn_header{payee} = $payee;
}

# add a transaction line. Call this multiple times to accmulate lines that will
# be emitted as soon as the transaction is over
sub push_line($$) {
    my ($depth, $line) = @_;

    push @cur_txn_lines, indent($depth, $line);
}

# add a comment line. Wrapper around push_line() for comments
sub push_comment($$) {
    my ($depth, $comment) = @_;

    # XXX workaround for bug
    # https://bitbucket.org/blais/beancount/issues/143/full-line-comments-not-allowed-within
    push_line($depth, pp_metadata("comment", '"' . $comment . '"'));
}


# return a pretty printed transaction, reseting the current parsing state. This
# is usually called as soon as the end of a transaction (usually an empty line)
# is encountered
sub pop_txn() {
    my $buf = "";

    $buf .= pp_cur_header() . "\n";
    $buf .= pp_cur_lines();

    reset_cur_txn();

    return $buf;
}


# parse a ledger value. Usually to extract "semantic" values from typed
# metadata
sub parse_ledger_value($) {
    my ($raw) = @_;
    my $value;

    if ($raw =~ /^\[(?<date>\d{4}-\d{2}-\d{2})\]$/) {
	$value = $+{date};
    } else {
	$value = $raw;
    }

    return $value;
}


# map a (ledger) metadata key to the desired (beancount) metadata key. Relies
# on the global %metadata_map hash
sub map_metadata($) {
    my ($key) = @_;

    if (exists($metadata_map{$key})) {
	return $metadata_map{$key};
    } else {
	return $key;
    }
}


# emit a single line
sub print_line($$) {
    my ($depth, $line) = @_;

    print indent($depth, $line), "\n";
}


# MAIN CONVERSION LOOP

while (my $l = <>) {
    # print "D: line: ", "\n"; dump_cur_txn(); print "\n";

    # handle line indentation once and for all
    chomp $l;
    $l =~ /^(?<indent>\s*)(?<line>.*)/;
    my $depth = ceil(length($+{indent}) / $ledger_indent);
      # round up with ceil() because we mix 4 (postings) and 2 (posting tags) indent in ledger
    $l = $+{line};

    if ($l =~ /^include\s+(?<filename>.*)\.ledger/) {  # include
	print_line $depth, "include \"$+{filename}.beancount\"";
    } elsif ($l =~ /^(?<date>[0-9]\S+)\s+(?<flag>[*!])\s+(?<narration>.*)/) {
	# txn header
	push_header($+{date}, $+{flag}, $+{narration});
    } elsif ($l =~ /^;\s*(?<key>[\w-]+):(?<typed>:)?\s*(?<value>.*)/) {
	# metadata comment
	my $key = map_metadata(lc($+{key}));
	my $value;
	if (defined($+{typed})) {
	    $value = parse_ledger_value($+{value});
	} else {
	    $value = '"' . $+{value} . '"';
	}
	if ($key eq $payee_tag) {
	    push_payee($+{value});
	} else {
	    push_line($depth, pp_metadata($key, $value));
	}
    } elsif ($l =~ /^;\s*(?<comment>.*)\s+:(?<tags>[\w:-]+):\s*$/
	     or $l =~ /^;\s+:(?<tags>[\w:-]+):\s+(?<comment>.*)$/) {
    	# tags comment
    	if ($in_txn) {
    	    push_line($depth, pp_tags(split(/:/, $+{tags})));
    	    push_comment($depth, $+{comment}) if $+{comment} ne "";
    	} else {
    	    print_line $depth, $l;
    	}
    } elsif ($l =~ /^;\s*(?<comment>.*)/) {  # (every other) comment
	if ($in_txn) {
	    push_comment($depth, $+{comment});
	} else {
	    print_line $depth, $l;
	}
    } elsif ($l =~ /^$/) {  # empty line
	print(pop_txn()) if $in_txn;
	print "\n";
    } else {  # everything else
	if ($in_txn) {
	    push_line($depth, $l);
	} else {
	    print_line $depth, $l;
	}
    }
}

# emit last transaction, if it's still active when reaching EOF
print(pop_txn()) if $in_txn;
